#!/usr/bin/env python

import os
import sys
import math
import json

# These files are read, not written.
RESULT_FILENAME = "result.json"
RUNDATA_FILENAME = "rundata.json"
RUNTIME_FILENAME = "runtime.txt"
STDERR_FILENAME = "stderr.log"
STDOUT_FILENAME = "stdout.log"
STATIC_CONFIGURATION_FILENAME = "static_configuration.json"
DYNAMIC_CONFIGURATION_FILENAME = "dynamic_configuration.json"
RUN_OUTPUT_PATH = "run_output"

# dict entries in rundata.json
TIMESTAMP_START = "timestamp_start"
TIMESTAMP_END = "timestamp_end"
RETURN_CODE = "return_code"
VALIDATION = "validation"
RUNTIME = "runtime"

def read_json_file(filename):
    """ returns an array containing the content of the JSON file.

    keyword arguments:
    filename -- name of json file to interpret
    """
    with open(filename, "r") as file:
        return json.loads(str(file.read()))


def get_nth_moment (result_times, n):
    """ 
    Calculates the nth moment of a list.

    Keyword values:
    result_times -- list of result times (floats)
    n -- integer describing that statistical moment of result_times which is returned
    """
    powers = map(lambda x: x**n, result_times)
    return sum(powers)/float(len(powers))

def get_average_and_stddev (result_times):
    """ Returns average and stddev for a list.

    Keyword values:
    result_times -- list of result times (floats)
    """
    av = get_nth_moment(result_times, 1)
    return (av, math.sqrt(get_nth_moment(result_times, 2) - av**2))


class Run:
    def __init__(self, benchmark,
                 implementation,
                 static_configuration,
                 case,
                 dynamic_configuration,
                 runnum,
                 directory):
        self.benchmark = benchmark
        self.implementation = implementation
        self.static_configuration = static_configuration
        self.case = case
        self.dynamic_configuration = dynamic_configuration
        self.name = runnum
        self.directory = directory
        rundir_content = [RESULT_FILENAME, RUNTIME_FILENAME,\
                          STDERR_FILENAME, STDOUT_FILENAME, RUNDATA_FILENAME]
        dircontents = os.listdir(self.directory)
        N = len(rundir_content)
        for i in range(N):
            if not rundir_content[i] in dircontents:
                raise Exception("The folder %s does not contain the file %s." %
                                (self.directory, rundir_content[i]))
        with open(os.path.join(self.directory,
                               RUNTIME_FILENAME), "r") as runtime_fp:
            with open(os.path.join(self.directory,
                                   STDERR_FILENAME), "r") as stderr_fp:
                with open(os.path.join(self.directory,
                                       STDOUT_FILENAME), "r") as stdout_fp:
                    try:
                        rd_dict_path = os.path.join(self.directory,
                                                    RUNDATA_FILENAME)
                        rd_dict = read_json_file(rd_dict_path)
                        self.retcode = int(rd_dict[RETURN_CODE])
                        self.ts_start = float(rd_dict[TIMESTAMP_START])
                        self.ts_end = float(rd_dict[TIMESTAMP_END])
                        self.validation = int(rd_dict[VALIDATION])
                        self.runtime = int(runtime_fp.read())
                        self.stderr = str(stderr_fp.read())
                        self.stdout = str(stdout_fp.read())
                    except ValueError as e:
                        # How are the arguments of the exception presented?
                        raise Exception("The content of one of\
                        the result files in %s was malformed:\
                        %s." % (self.directory, e.args()))

    def __str__(self):
        return "benchmark: {0}, \
        implementation: {1}, \
        static configuration: {2}, \
        dataset: {3}, \
        dynamic configuration: {4}\
        run number: {5}"\
        .format(self.benchmark.name,
                self.implementation.name,
                str(self.static_configuration.configuration),
                self.case.name,
                str(self.dynamic_configuration.configuration),
                str(self.name))

class Dynamic_configuration:
    def __init__(self, benchmark, implementation,
                 static_configuration, case, name, directory):
        self.benchmark = benchmark
        self.implementation = implementation
        self.static_configuration = static_configuration
        self.case = case
        self.name = name
        self.directory = directory
        self.runs = {}
        dconf_filename = os.path.join(self.directory,
                                      DYNAMIC_CONFIGURATION_FILENAME)
        if not os.path.isfile(dconf_filename):
            raise Exception("%s does not contain a file describing its \
            runtime variables. If no runtime vars, a file containing \
            \"{}\" should still be here." % self.directory)
        try:
            self.configuration = read_json_file(dconf_filename)
        except ValueError as e:
            print("Error reading JSON")
            print(e.args)
            raise Exception("Error reading JSON file %s", dconf_filename)
        dircontents = os.listdir(self.directory)
        for run in dircontents:
            if run == DYNAMIC_CONFIGURATION_FILENAME:
                continue
            runpath = os.path.join(self.directory, run)
            if not os.path.isdir(runpath):
                raise Exception("%s may only contain %s and directories \
                containing runs. %s is neither." %
                                (self.directory, DYNAMIC_CONFIGURATION_FILENAME,
                                 runpath))
            try:
                runnum = int(run)
                if runnum < 0:
                    raise Exception("Only non-negative run numbers (i.e., directory names)\
                are allowed in %s." % target_dir)
                self.runs[runnum] = Run(self.benchmark, self.implementation,
                                        self.static_configuration, self.case,
                                        self, runnum, runpath)
            except ValueError:
                raise Exception("The folder %s may only contain folders with\
                integer name." % self.directory)


    def __str__(self):
        return "benchmark: {0}, \
        implementation: {1}, \
        static configuration: {2}, \
        dataset: {3}, \
        dynamic configuration: {4}"\
        .format(self.benchmark.name,
                self.implementation.name,
                str(self.static_configuration.configuration),
                self.case.name,
                str(self.configuration))
            
            

    # The dynamic configuration JSON is stored in the folder with
    # the name of the configuration. (hash(dict)).
    # A dynamic configuration contains a number of runs.
    # The name, the dict, and the number of runs should be stored.
    # The folder structure should be tested: dyn. conf. must exist,
    # and folder names must be ints.

# A case now also contains a static configuration parameteer
class Case:
    def __init__(self, benchmark, implementation,
                 static_configuration, name, directory):
        self.benchmark = benchmark
        self.implementation = implementation
        self.static_configuration = static_configuration
        self.name = name # name of a dataset.
        self.directory = directory
        self.dynamic_configurations = {}
        dircontents = os.listdir(self.directory)
        for dconf in dircontents:
            dconf_path = os.path.join(self.directory, dconf)
            if not os.path.isdir(dconf_path):
                raise Exception("%s may only contain folder containing dynamic\
                variables configurations. %s is not a folder" %
                                (self.directory,
                                 dconf_path))
            self.dynamic_configurations[dconf] \
                = Dynamic_configuration(self.benchmark,
                                        self.implementation,
                                        self.static_configuration,
                                        self,
                                        dconf,
                                        dconf_path)

    def __str__(self):
        return "benchmark: {0}, \
        implementation: {1}, \
        static configuration: {2}, \
        dataset: {3}"\
        .format(self.benchmark.name,
                self.implementation.name,
                str(self.static_configuration.configuration),
                self.name)
    
class Static_configuration:
    def __init__(self, benchmark, implementation, name, directory):
        self.benchmark = benchmark
        self.implementation = implementation
        self.name = name
        self.directory = directory
        self.cases = {}
        sconf_filename = os.path.join(self.directory,
                                      STATIC_CONFIGURATION_FILENAME)
        run_output_path = os.path.join(self.directory,
                                       RUN_OUTPUT_PATH)
        self.run_output_path = run_output_path
        if not os.path.isfile(sconf_filename):
            raise Exception("%s does not contain a file describing its \
            compile-time variables. If no compile-time vars, a file containing \
            \"{}\" should still be here." % self.directory)
        if not os.path.isdir(run_output_path):
            raise Exception("%s does not contain a folder called %s as it \
            should." % (self.directory, RUN_OUTPUT_PATH))
        # what if this is a malformed JSON??
        try:
            self.configuration = read_json_file(sconf_filename)
        except ValueError as e:
            print("\n" + str(e.args) + "\n")
            raise Exception("Error reading JSON file: %s" % sconf_filename)
        datasets = os.listdir(run_output_path)
        empty = True
        for dataset in datasets:
            empty = False
            dataset_path = os.path.join(run_output_path, dataset)
            if not os.path.isdir(dataset_path):
                raise Exception("The folder %s may only contain folders with \
                names of datasets." % run_output_path)
            self.cases[dataset] = Case(self.benchmark,
                                       self.implementation,
                                       self,
                                       dataset,
                                       dataset_path)
        if empty:
            raise Exception("%s does not contain folder(s) for datasets as it\
            should" % run_output_path)

    def __str__(self):
        return "benchmark: {0}, \
        implementation: {1}, \
        static configuration: {2}"\
        .format(self.benchmark.name,
                self.implementation.name,
                str(self.configuration))
    
class Implementation:
    def __init__(self, benchmark, name, directory):
        self.benchmark = benchmark
        self.name = name
        self.directory = directory
        self.static_configs = {}
        empty = True
        # contains only folders with statconf names.
        dircontents = os.listdir(self.directory)
        for sconf in dircontents:
            empty = False
            sconf_dir = os.path.join(self.directory, sconf)
            if not os.path.isdir(sconf_dir):
                raise Exception("The content of %s must be folders with names \
                for static configurations (hash values).\
                But %s is not a folder." % (run_outputdir, sconf_dir))
            # Here, the keys of the cases will be hash values.
            self.static_configs[sconf] = \
            Static_configuration(self.benchmark, self,
                                 sconf, sconf_dir)
        if empty:
                raise Exception("No folders for static configurations was found\
                in %s." % self.directory)
            
    def __str__(self):
        return "benchmark: {0}, \
        implementation: {1}"\
        .format(self.benchmark.name,
                self.name)
    
class Benchmark:
    def __init__(self, name, directory):
        self.name = name
        self.directory = directory
        self.implementations = {}
        dircontents = os.listdir(self.directory)
        for impl in dircontents:
            impldir = os.path.join(self.directory, impl)
            if not os.path.isdir(impldir):
                raise Exception("The folder containing the %s benchmark must\
                only contain directories. %s is not a directory." %
                                (self.name, impldir))
            implname = os.path.basename(impldir)
            self.implementations[implname] = Implementation(self,
                                                            implname,
                                                            impldir)
            
    def __str__(self):
        """ This function allows for printing of benchmark objects.
        """
        a = "benchmark: {0}".format(self.name)
        return a

# Why is rootdir needed? It allows for relative paths upon execution!
# This program could also demand a benchmark as sys.argv[1] thus only
# allowing it to analyze one benchmark at a time.
if len(sys.argv) != 2:
    raise Exception("Usage %s <directory_containing_hipermark_results>" %
                    sys.argv[0])
instdir = sys.argv[1]
if not os.path.isdir(instdir):
    raise Exception("Directory %s could not be found." % sys.argv[1])
dircontents = os.listdir(instdir)
b = {}
rootdir = os.getcwd()
for bm in dircontents:
    bmdir = os.path.join(rootdir, instdir, bm)
    if not os.path.isdir(bmdir):
        raise Exception("Only directories may be placed in %s. %s is not a \
        directory." % (sys.argv[1], bm))
    name = os.path.basename(os.path.normpath(bm))
    b[name] = Benchmark(name, bmdir)


def get_y_vs_x(y_name, x_name):
    """ Given a certain benchmark, this should allow the user to select one free 
    variable and one dependent variable. """

def get_static_var_names(implementation):
    """Returns a list of all static (compile time) configuration variable names.
    Returns the empty list if there are no
    """
    if implementation.static_configs == {}:
        return []
    first = True
    for sconf_name in implementation.static_configs:
        static_conf = implementation.static_configs[sconf_name]
        if first:
            static_var_names= []
            for var in static_conf.configuration:
                static_var_names.append(var)
                # This should also record and return the type!!
                first = False
            else:
                # if not the first static configuration in the list, we demand
                # that the dictionary contain the same keys as the first.
                sconf_keys = list(static_conf.configuration.keys())
                if not set(static_var_names) == set(sconf_keys):
                    raise Exception("Static configuration keys differ for \
                    implementation %s" % implementation.name)
    # convert from unicode to string before returning            
    return map(lambda name: str(name), static_var_names)

def get_dataset_names(implementation):
    """ Returns a list of all dataset names used in a given implementation.
    Also checks if the set of datasets is equivalent for all static 
    configurations.
    """
    first = True
    for sconf_name in implementation.static_configs:
        if first:
            static_config = implementation.static_configs[sconf_name]
            # looping (mapping) over all values of the cases dictionary.
            dataset_names = map(lambda case: case.name, static_config.cases.itervalues())
            first = False
        else:
            static_config = implementation.static_configs[sconf_name]
            dataset_names_new = map(lambda case: case.name, static_config.cases.itervalues())
            if not set(dataset_names) == set(dataset_names_new):
                raise Exception("The static configuration of implementation \
                %s do not agree of dataset names. Both %s, and %s were observed\
                " % (implementation.name, dircontents, dircontents_new))
    # convert from unicode to string before returning            
    return map(lambda name: str(name), dataset_names)

#def get_runtime_var_names(implementation):

def get_var_names(implementation):
    """Returns the variable names that a specific implementation contains.
    The return type is a dict with list of strings as values.
    """
    variables = {}
    variables["static_configurations"] = get_static_var_names(implementation)
    variables["datasets"] = get_dataset_names(implementation)
    #variables["runtime_configurations"] = get_runtime_var_names(implementation)
    return variables

# Testing occurs below this line. Specific dataset is needed for this to work.    
lvc = b['OptionPricing']
print(lvc)
compn = lvc.implementations['cpp_openmp']
var_names = get_var_names(compn)
print("The static var names are:")
print(var_names["static_configurations"])
print("The dataset names are:")
print(var_names["datasets"])
print(compn)
sc0 = compn.static_configs['b335a81d722b']
print(sc0)
medium = sc0.cases['small']
print(medium)
dc0 = medium.dynamic_configurations['0ea96b5a5a40']
print(dc0)
run0 = dc0.runs[0]
print(run0)
print("Retcode: {0}\n runtime: {1}\n stderr: {2}\n stdout: {3}\n ts end: {4}\n ts start: {5}\n validation: {6}".format(run0.retcode, run0.runtime, run0.stderr, run0.stdout, run0.ts_end, run0.ts_start, run0.validation))
