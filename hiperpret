#!/usr/bin/env python

import os
import sys
import math
import json

# CAPITALIZE CONST NAMES
RESULT_FILENAME = "result.json"
RETURNCODE_FILENAME = "returncode.txt"
RUNTIME_FILENAME = "runtime.txt"
STDERR_FILENAME = "stderr.log"
STDOUT_FILENAME = "stdout.log"
TIMESTAMP_END_FILENAME = "tsendrun.txt"
TIMESTAMP_START_FILENAME = "tsstartrun.txt"
VALIDATION_FILENAME = "validation.txt"
STATIC_CONFIGURATION_FILENAME = "static_configuration.json"
DYNAMIC_CONFIGURATION_FILENAME = "dynamic_configuration.json"
RUN_OUTPUT_PATH = "run_output"

def read_json_file(filename):
    """ returns an array containing the content of the JSON file.

    keyword arguments:
    filename -- name of json file to interpret
    """
    with open(filename, "r") as file:
        return json.loads(str(file.read()))


def get_nth_moment (result_times, n):
    """ 
    Calculates the nth moment of a list.

    Keyword values:
    result_times -- list of result times (floats)
    n -- integer describing that statistical moment of result_times which is returned
    """
    # rewrite to use map.
    suml = 0
    N = len(result_times)
    for i in range(N):
        suml += result_times[i]**n
    return (suml/float(N))

def get_average_and_stddev (result_times):
    """ Returns average and stddev for a list.

    Keyword values:
    result_times -- list of result times (floats)
    """
    av = get_nth_moment(result_times, 1)
    return (av, math.sqrt(get_nth_moment(result_times, 2) - av**2))


class Run:
    def __init__(self, benchmark,
                 implementation,
                 static_configuration,
                 case,
                 dynamic_configuration,
                 runnum,
                 directory):
        self.benchmark = benchmark
        self.implementation = implementation
        self.static_configuration = static_configuration
        self.case = case
        self.dynamic_configuration = dynamic_configuration
        self.name = runnum
        self.directory = directory
        rundir_content = [RESULT_FILENAME, RETURNCODE_FILENAME, RUNTIME_FILENAME,\
                          STDERR_FILENAME, STDOUT_FILENAME, TIMESTAMP_END_FILENAME,\
                          TIMESTAMP_START_FILENAME, VALIDATION_FILENAME]
        dircontents = os.listdir(self.directory)
        N = len(rundir_content)
        for i in range(N):
            if not rundir_content[i] in dircontents:
                raise Exception("The folder %s does not contain the file %s." %
                                (self.directory, rundir_content[i]))
        with open(os.path.join(self.directory,
                               RETURNCODE_FILENAME), "r") as retcode_fp:
            with open(os.path.join(self.directory,
                                   RUNTIME_FILENAME), "r") as runtime_fp:
                with open(os.path.join(self.directory,
                                       STDERR_FILENAME), "r") as stderr_fp:
                    with open(os.path.join(self.directory,
                                           STDOUT_FILENAME), "r") as stdout_fp:
                        with open(os.path.join(self.directory,
                                               TIMESTAMP_END_FILENAME), "r") as ts_end_fp:
                            with open(os.path.join(self.directory,
                                                   TIMESTAMP_START_FILENAME), "r") as ts_start_fp:
                                with open(os.path.join(self.directory,
                                                       VALIDATION_FILENAME), "r") as validation_fp:                        
                                    try:
                                        self.retcode = int(retcode_fp.read())
                                        self.runtime = int(runtime_fp.read())
                                        self.stderr = str(stderr_fp.read())
                                        self.stdout = str(stdout_fp.read())
                                        self.ts_end = float(ts_end_fp.read())
                                        self.ts_start = float(ts_start_fp.read())
                                        self.validation = int(validation_fp.read())
                                    except ValueError as e:
                                        # How are the arguments of the exception presented?
                                        raise Exception("The content of one of\
                                        the result files in %s was malformed:\
                                        %s." % (self.directory, e.args()))

    def __str__(self):
        return "benchmark: {0}, \
        implementation: {1}, \
        static configuration: {2}, \
        dataset: {3}, \
        dynamic configuration: {4}\
        run number: {5}"\
        .format(self.benchmark.name,
                self.implementation.name,
                str(self.static_configuration.dict),
                self.case.name,
                str(self.dynamic_configuration.dict),
                str(self.name))

class Dynamic_configuration:
    def __init__(self, benchmark, implementation,
                 static_configuration, case, name, directory):
        self.benchmark = benchmark
        self.implementation = implementation
        self.static_configuration = static_configuration
        self.case = case
        self.name = name
        self.directory = directory
        self.runs = {}
        dconf_filename = os.path.join(self.directory,
                                      DYNAMIC_CONFIGURATION_FILENAME)
        if not os.path.isfile(dconf_filename):
            raise Exception("%s does not contain a file describing its \
            runtime variables. If no runtime vars, a file containing \
            \"{}\" should still be here." % self.directory)
        try:
            self.dict = read_json_file(dconf_filename)
        except ValueError as e:
            print("Error reading JSON")
            print(e.args)
            raise Exception("Error reading JSON file %s", dconf_filename)
        dircontents = os.listdir(self.directory)
        for run in dircontents:
            if run == DYNAMIC_CONFIGURATION_FILENAME:
                continue
            runpath = os.path.join(self.directory, run)
            if not os.path.isdir(runpath):
                raise Exception("%s may only contain %s and directories \
                containing runs. %s is neither." %
                                (self.directory, DYNAMIC_CONFIGURATION_FILENAME,
                                 runpath))
            try:
                runnum = int(run)
                if runnum < 0:
                    raise Exception("Only non-negative run numbers (i.e., directory names)\
                are allowed in %s." % target_dir)
                self.runs[runnum] = Run(self.benchmark, self.implementation,
                                        self.static_configuration, self.case,
                                        self, runnum, runpath)
            except ValueError:
                raise Exception("The folder %s may only contain folders with\
                integer name." % self.directory)


    def __str__(self):
        return "benchmark: {0}, \
        implementation: {1}, \
        static configuration: {2}, \
        dataset: {3}, \
        dynamic configuration: {4}"\
        .format(self.benchmark.name,
                self.implementation.name,
                str(self.static_configuration.dict),
                self.case.name,
                str(self.dict))
            
            

    # The dynamic configuration JSON is stored in the folder with
    # the name of the configuration. (hash(dict)).
    # A dynamic configuration contains a number of runs.
    # The name, the dict, and the number of runs should be stored.
    # The folder structure should be tested: dyn. conf. must exist,
    # and folder names must be ints.

# A case now also contains a static configuration parameteer
class Case:
    def __init__(self, benchmark, implementation,
                 static_configuration, name, directory):
        self.benchmark = benchmark
        self.implementation = implementation
        self.static_configuration = static_configuration
        self.name = name # name of a dataset.
        self.directory = directory
        self.dynamic_configurations = {}
        dircontents = os.listdir(self.directory)
        for dconf in dircontents:
            dconf_path = os.path.join(self.directory, dconf)
            if not os.path.isdir(dconf_path):
                raise Exception("%s may only contain folder containing dynamic\
                variables configurations. %s is not a folder" %
                                (self.directory,
                                 dconf_path))
            self.dynamic_configurations[dconf] \
                = Dynamic_configuration(self.benchmark,
                                        self.implementation,
                                        self.static_configuration,
                                        self,
                                        dconf,
                                        dconf_path)

    def __str__(self):
        return "benchmark: {0}, \
        implementation: {1}, \
        static configuration: {2}, \
        dataset: {3}"\
        .format(self.benchmark.name,
                self.implementation.name,
                str(self.static_configuration.dict),
                self.name)
    
class Static_configuration:
    def __init__(self, benchmark, implementation, name, directory):
        self.benchmark = benchmark
        self.implementation = implementation
        self.name = name
        self.directory = directory
        self.cases = {}
        sconf_filename = os.path.join(self.directory,
                                      STATIC_CONFIGURATION_FILENAME)
        run_output_path = os.path.join(self.directory,
                                       RUN_OUTPUT_PATH)
        if not os.path.isfile(sconf_filename):
            raise Exception("%s does not contain a file describing its \
            compile-time variables. If no compile-time vars, a file containing \
            \"{}\" should still be here." % self.directory)
        if not os.path.isdir(run_output_path):
            raise Exception("%s does not contain a folder called %s as it \
            should." % (self.directory, RUN_OUTPUT_PATH))
        # what if this is a malformed JSON??
        try:
            self.dict = read_json_file(sconf_filename)
        except ValueError as e:
            print("\n" + str(e.args) + "\n")
            raise Exception("Error reading JSON file: %s" % sconf_filename)
        datasets = os.listdir(run_output_path)
        empty = True
        for dataset in datasets:
            empty = False
            dataset_path = os.path.join(run_output_path, dataset)
            if not os.path.isdir(dataset_path):
                raise Exception("The folder %s may only contain folders with \
                names of datasets." % run_output_path)
            self.cases[dataset] = Case(self.benchmark,
                                       self.implementation,
                                       self,
                                       dataset,
                                       dataset_path)
        if empty:
            raise Exception("%s does not contain folder(s) for datasets as it\
            should" % run_output_path)

    def __str__(self):
        return "benchmark: {0}, \
        implementation: {1}, \
        static configuration: {2}"\
        .format(self.benchmark.name,
                self.implementation.name,
                str(self.dict))
    
class Implementation:
    def __init__(self, benchmark, name, directory):
        self.benchmark = benchmark
        self.name = name
        self.directory = directory
        self.static_configs = {}
        empty = True
        # contains only folders with statconf names.
        dircontents = os.listdir(self.directory)
        for sconf in dircontents:
            empty = False
            sconf_dir = os.path.join(self.directory, sconf)
            if not os.path.isdir(sconf_dir):
                raise Exception("The content of %s must be folders with names \
                for static configurations (hash values).\
                But %s is not a folder." % (run_outputdir, sconf_dir))
            # Here, the keys of the cases will be hash values.
            self.static_configs[sconf] = \
            Static_configuration(self.benchmark, self,
                                 sconf, sconf_dir)
        if empty:
                raise Exception("No folders for static configurations was found\
                in %s." % self.directory)
            
    def __str__(self):
        return "benchmark: {0}, \
        implementation: {1}"\
        .format(self.benchmark.name,
                self.name)
    
class Benchmark:
    def __init__(self, name, directory):
        self.name = name
        self.directory = directory
        self.implementations = {}
        dircontents = os.listdir(self.directory)
        for impl in dircontents:
            impldir = os.path.join(self.directory, impl)
            if not os.path.isdir(impldir):
                raise Exception("The folder containing the %s benchmark must\
                only contain directories. %s is not a directory." %
                                (self.name, impldir))
            implname = os.path.basename(impldir)
            self.implementations[implname] = Implementation(self,
                                                            implname,
                                                            impldir)
            
    def __str__(self):
        """ This function allows for printing of benchmark objects.
        """
        a = "benchmark: {0}".format(self.name)
        return a

# Why is rootdir needed? It allows for relative paths upon execution!
# This program could also demand a benchmark as sys.argv[1] thus only
# allowing it to analyze one benchmark at a time.
if len(sys.argv) != 2:
    raise Exception("Usage %s <directory_containing_hipermark_results>" %
                    sys.argv[0])
instdir = sys.argv[1]
if not os.path.isdir(instdir):
    raise Exception("Directory %s could not be found." % sys.argv[1])
dircontents = os.listdir(instdir)
b = {}
rootdir = os.getcwd()
for bm in dircontents:
    bmdir = os.path.join(rootdir, instdir, bm)
    if not os.path.isdir(bmdir):
        raise Exception("Only directories may be placed in %s. %s is not a \
        directory." % (sys.argv[1], bm))
    name = os.path.basename(os.path.normpath(bm))
    b[name] = Benchmark(name, bmdir)

# Testing occurs below this line. Specific dataset is needed for this to work.    
lvc = b['LocVolCalib']
print(lvc)
compn = lvc.implementations['cpp_openmp_naive']
print(compn)
sc0 = compn.static_configs['11b90a2e2f08']
print(sc0)
medium = sc0.cases['medium']
print(medium)
dc0 = medium.dynamic_configurations['5171205a378a']
print(dc0)
run0 = dc0.runs[0]
print(run0)
print("Retcode: {0}\n runtime: {1}\n stderr: {2}\n stdout: {3}\n ts end: {4}\n ts start: {5}\n validation: {6}".format(run0.retcode, run0.runtime, run0.stderr, run0.stdout, run0.ts_end, run0.ts_start, run0.validation))
